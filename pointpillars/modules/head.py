# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/04_modules.head.ipynb (unless otherwise specified).

__all__ = ['logger', 'Head']

# Cell
import logging
import ast
import torch
import torch.nn as nn
import torch.nn.functional as F

logger = logging.getLogger(__name__)

# Cell
class Head(nn.Module):

    def __init__(self, head_cfg):
        """Definition of the relevant module attributes and conv layers"""

        logger.info("Initialize detection head...")
        super(Head, self).__init__()
        # TODO: define in channel properly
        self.num_anchors = len(ast.literal_eval(head_cfg['anchors']))
        # x,y,z,w,l,h,theta
        # x,y,z,h,w,l,theta (maybe occupancy to define if object is present)
        self.num_attributes = 7

        self.conv_occ = nn.Conv2d(384, self.num_anchors, 1)
        self.conv_cls = nn.Conv2d(384, self.num_anchors, 1)
        self.conv_head = nn.Conv2d(384, self.num_anchors, 1)

        self.conv_boxes = nn.Conv2d(384, self.num_anchors * self.num_attributes, 1)

        logger.debug("Detection head init complete.")


    def forward(self, batch: torch.Tensor) -> tuple:
        """
        :param batch: a batch of data coming from the feature net

        :returns:   (pred_occ(N, H, W, nb_anchors),
                     pred_cls(N, H, W, nb_anchors),
                     pred_head(N, H, W, nb_anchors),
                     pred_boxes(N, H, W, nb_anchors, nb_attributes=7))

                     Meaning of the values:
                     pred_occ gives the confidence of an object occupying this anchor
                     pred_cls gives the predicted class of the object in this anchor
                     pred_head gives the binary prediction of the direction the object is facing (away or towards cam)
                     pred_box gives the dimension deltas to this anchors center (also dependant on pillar center)
        """
        logger.info("Forward through detection head...")
        logger.debug(f"batch: {batch}{batch.shape}")

        pred_occ = self.conv_occ(batch)
        pred_cls = self.conv_cls(batch)
        pred_head = self.conv_head(batch)
        # permute (batch_size, n_anchors, H, W) -> (batch_size, H, W, n_anchors)
        pred_occ = pred_occ.permute(0, 2, 3, 1)
        pred_cls = pred_cls.permute(0, 2, 3, 1)
        pred_head = pred_head.permute(0, 2, 3, 1)

        pred_boxes = self.conv_boxes(batch)
        C, H, W = pred_boxes.shape[1:]
        # resize and permute to fit the correct dimensions
        # out: (batch_size, H, W, n_anchors, 7)
        pred_boxes = pred_boxes.reshape(-1, self.num_anchors, self.num_attributes, H, W).permute(0, 3, 4, 1, 2)

        """
        # h, l, w must be positive even with random weights, use relu to ensure
        pred_boxes_hwl = pred_boxes[:,:,:,:,3:6]
        F.relu(pred_boxes_hwl, inplace=True)
        pred_boxes = torch.cat((pred_boxes[:,:,:,:,:3], pred_boxes_hwl, pred_boxes[:,:,:,:,6:]), dim=4)
        del pred_boxes_hwl
        """


        logger.debug(f"Forward pass through head complete.\n"
                     f"pred_occ: {pred_occ}{pred_occ.shape},\n"
                     f"pred_cls: {pred_cls}{pred_cls.shape},\n"
                     f"pred_head: {pred_head}{pred_head.shape},\n"
                     f"pred_boxes: {pred_boxes}{pred_boxes.shape}")

        return pred_occ, pred_cls, pred_head, pred_boxes

