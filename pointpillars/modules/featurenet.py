# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/04_modules.featurenet.ipynb (unless otherwise specified).

__all__ = ['logger', 'FeatureNet']

# Cell
import logging
import torch
import torch.nn as nn
import torch.nn.functional as F

logger = logging.getLogger(__name__)

# Cell
class FeatureNet(nn.Module):
    def __init__(self, fnet_cfg, pil_cfg):
        super(FeatureNet, self).__init__()

        # config data
        self.in_chan = fnet_cfg.getint("nb_features")
        self.out_chan = fnet_cfg.getint("nb_channels")
        self.max_ppp = pil_cfg.getint("max_points_per_pillar")
        self.fnet_cfg = fnet_cfg
        self.pil_cfg = pil_cfg

        # xy dimensions for pseudo image
        x_min = self.pil_cfg.getfloat("x_min")
        x_max = self.pil_cfg.getfloat("x_max")
        x_step = self.pil_cfg.getfloat("x_step")
        y_min = self.pil_cfg.getfloat("y_min")
        y_max = self.pil_cfg.getfloat("y_max")
        y_step = self.pil_cfg.getfloat("y_step")

        self.n_x = int((x_max - x_min) / x_step)
        self.n_y = int((y_max - y_min) / y_step)

        self.conv1 = nn.Conv2d(self.in_chan, self.out_chan, 1)
        self.batchn = nn.BatchNorm2d(self.out_chan)
        self.relu = nn.ReLU()
        self.maxpool = nn.MaxPool2d([1, self.max_ppp])

    def forward(self, pil_batch: torch.tensor, ind_batch: torch.tensor):
        """Simplified point net to create a pseudo image from the point cloud."""
        if pil_batch.shape[0] != ind_batch.shape[0]:
            raise ValueError("The dimensions of the pillar batch and indices batch do not match.")

        # simplified PointNet
        # in: (N_b, D=9, N, P), out: (N_b, C_out, N, P)
        pil_batch = self.conv1(pil_batch)
        pil_batch = self.batchn(pil_batch)
        pil_batch = self.relu(pil_batch)
        # in: (N_b, C_out, N, P), out: (N_b, C_out, N)
        pil_batch = self.maxpool(pil_batch)

        n_b, n_c, n_x, n_y = pil_batch.shape

        # scatter points back to pillar position
        pse_img = torch.zeros([pil_batch.shape[0],
                               pil_batch.shape[1],
                               self.n_x,
                               self.n_y],
                               dtype=torch.float,
                               device="cuda:0")

        # flatten indices and pil_batch,
        # and also get the corresponding flat indices so torch.put() can be used
        batch_ind = torch.cuda.FloatTensor(range(n_b))
        batch_ind = batch_ind.unsqueeze(1).expand(-1, n_c)
        batch_ind = batch_ind.unsqueeze(2).expand(-1, -1, n_x).cuda()

        feat_ind = torch.cuda.FloatTensor(range(n_c))
        feat_ind = feat_ind.unsqueeze(0).expand(n_b, -1)
        feat_ind = feat_ind.unsqueeze(2).expand(-1, -1, n_x).cuda()

        ind_batch = ind_batch.unsqueeze(1).expand(-1, n_c, -1, -1)
        x_ind = ind_batch[:,:,:,0].cuda()
        y_ind = ind_batch[:,:,:,1].cuda()

        # calculate flat indices with batch, feature, x and y indices
        index = batch_ind * n_b + feat_ind * n_c + x_ind * n_x + y_ind
        index = index.type(torch.LongTensor)
        del batch_ind, feat_ind, x_ind, y_ind

        index = torch.flatten(index)
        pil_batch = torch.flatten(pil_batch)

        return pse_img.put_(index.cuda(), pil_batch)

        # old version
        #ind_x_batch = ind_batch.unsqueeze(1).expand(-1, pil_batch.shape[1], -1, -1)[:,:,:,0].unsqueeze(3).cuda()
        #ind_y_batch = ind_batch.unsqueeze(1).expand(-1, pil_batch.shape[1], -1, -1)[:,:,:,1].unsqueeze(3).cuda()
        #pse_img.scatter_(3, ind_x_batch, pil_batch)
        #pse_img.scatter_(2, ind_y_batch, pil_batch)
        #return pse_img[:,:,:self.n_x]
